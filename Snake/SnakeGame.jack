class SnakeGame {
    static SnakeGame instance;

    field Snake snake;
    field boolean exit;
    field int nodeSize, initX, initY;

    // field width = [0, 511]
    field int fieldWMin;
    field int fieldWMax;

    // field height = [0, 255]
    field int fieldHMin;
    field int fieldHMax;

    constructor SnakeGame new() {
        let exit = false;
        let nodeSize = 12;

        // 367 = nodeSize * 30 + 7
        let fieldWMin = 7;
        let fieldWMax = 367;

        // 247 = nodeSize * 20 + 7
        let fieldHMin = 7;
        let fieldHMax = 247;

        do Screen.clearScreen();

        // init field
        do Screen.setColor(true);
        do Screen.drawRectangle(fieldWMin, fieldHMin, fieldWMax, fieldHMax);
        do Screen.setColor(false);
        do Screen.drawRectangle(fieldWMin+1, fieldHMin+1, fieldWMax-1, fieldHMax-1);

        // init snake
        // 127 = nodeSize * 10 + 7
        let snake = Snake.new(127, 127, 5);

        return this;
    }

    function void newInstance() {
        let instance = SnakeGame.new();
        return;
    }

    function SnakeGame getInstance() {
        return instance;
    }

    method void dispose() {
        do Memory.deAlloc(this);
        return;
    }

    method boolean checkEating() {
        return true;
    }

    method boolean isGameOver() {
        var int d, headX, headY, nextX, nextY, x, y;
        var SnakeNode head, n;

        let d = snake.getDirection();
        let head = snake.getHead();

        // check if node will be inside the wall
        let headX = head.getX();
        let headY = head.getY();

        // up
        if (d = 0) {
            let nextX = headX;
            let nextY = headY - nodeSize;
            if (nextY < fieldHMin) {
                return true;
            }
        }
        // down
        if (d = 1) {
            let nextX = headX;
            let nextY = headY + nodeSize;
            if (nextY = fieldHMax) {
                return true;
            }
        }
        // left
        if (d = 2) {
            let nextX = headX - nodeSize;
            let nextY = headY;
            if (nextX < fieldWMin) {
                return true;
            }
        }
        // right
        if (d = 3) {
            let nextX = headX + nodeSize;
            let nextY = headY;
            if (nextX = fieldWMax) {
                return true;
            }
        }

        // check if node will be eating itself
        let n = head;
        while (~(n = null)) {
            let x = n.getX();
            let y = n.getY();
            if ((x = nextX) & (y = nextY)) {
                return true;
            }
            let n = n.getNext();
        }

        return false;
    }

    method void run() {
        var char key;

        while (~exit) {
            // waits for a key to be pressed.
            while ((key = 0) & (~exit)) {
                let key = Keyboard.keyPressed();

                if (isGameOver()) {
                    let exit = true;
                } else {
                    do snake.move();
                }
                do Sys.wait(500);
            }

            // Left Arrow = 130
            // Up Arrow = 131
            // Right Arrow = 132
            // Down Arrow = 133
            if (key = 131) {
                do snake.setDirection(0);
            }
            if (key = 133) {
                do snake.setDirection(1);
            }
            if (key = 130) {
                do snake.setDirection(2);
            }
            if (key = 132) {
                do snake.setDirection(3);
            }

            let key = 0;
        }


        if (exit) {
            do Output.moveCursor(10,19);
	        do Output.printString("Game Over");
        }

        return;
    }
}